<?php

namespace Illuminate\Database\Eloquent\Factories;

use BadMethodCallException;
use Closure;
use Faker\Generator;
use Illuminate\Container\Container;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Database\Eloquent\Collection as EloquentCollection;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Events\Dispatcher;
use Illuminate\Support\Collection;
use Illuminate\Support\Str;
use Illuminate\Support\Traits\Conditionable;
use Illuminate\Support\Traits\Macroable;
use ReflectionClass;
use Throwable;

/**
 * @method static static new(callable|array<string,mixed> $attributes)
 * @method static for(Factory|Model $factory, string|null $relationship)
 */
abstract class Factory
{
    use Conditionable, Macroable {
        __call as macroCall;
    }

    /**
     * The name of the factory's corresponding model.
     *
     * @var string|null
     */
    protected $model;

    /**
     * The number of models that should be generated.
     *
     * @var int|null
     */
    protected $count;

    /**
     * The state transformations that will be applied to the model.
     *
     * @var \Illuminate\Support\Collection
     */
    protected $states;

    /**
     * The parent relationships that will be applied to the model.
     *
     * @var \Illuminate\Support\Collection
     */
    protected $has;

    /**
     * The child relationships that will be applied to the model.
     *
     * @var \Illuminate\Support\Collection
     */
    protected $for;

    /**
     * The "after making" callbacks that will be applied to the model.
     *
     * @var \Illuminate\Support\Collection
     */
    protected $afterMaking;

    /**
     * The "after creating" callbacks that will be applied to the model.
     *
     * @var \Illuminate\Support\Collection
     */
    protected $afterCreating;

    /**
     * The name of the database connection that will be used to create the models.
     *
     * @var ?string
     */
    protected $connection;

    /**
     * The current Faker instance.
     *
     * @var \Faker\Generator
     */
    protected $faker;

    /**
     * The default namespace where factories reside.
     *
     * @var string
     */
    protected static $namespace = 'Database\\Factories\\';

    /**
     * The default model name resolver.
     *
     * @var ?callable
     */
    protected static $modelNameResolver;

    /**
     * The factory name resolver.
     *
     * @var ?callable
     */
    protected static $factoryNameResolver;

    /**
     * Create a new factory instance.
     *
     * @param  int|null  $count
     * @param  \Illuminate\Support\Collection|null  $states
     * @param  \Illuminate\Support\Collection|null  $has
     * @param  \Illuminate\Support\Collection|null  $for
     * @param  \Illuminate\Support\Collection|null  $afterMaking
     * @param  \Illuminate\Support\Collection|null  $afterCreating
     * @param  string|null  $connection
     * @return void
     */
    final public function __construct(
        $count = null,
        $states = null,
        $has = null,
        $for = null,
        $afterMaking = null,
        $afterCreating = null,
        $connection = null
    )
    {
        $this->count = $count;
        $this->states = $states ?: new Collection();
        $this->has = $has ?: new Collection();
        $this->for = $for ?: new Collection();
        $this->afterMaking = $afterMaking ?: new Collection();
        $this->afterCreating = $afterCreating ?: new Collection();
        $this->connection = $connection;
        $this->faker = $this->withFaker();
    }

    /**
     * Define the model's default state.
     *
     * @return array<string,mixed>
     */
    abstract public function definition();

    /**
     * Get a new factory instance for the given attributes.
     *
     * @param  callable|array<string,mixed>  $attributes
     * @return static
     */
    public static function newFactory($attributes = [])
    {
        return (new static())->state($attributes)->configure();
    }

    /**
     * Get a new factory instance for the given number of models.
     *
     * @param  int  $count
     * @return static
     */
    public static function times($count)
    {
        return static::newFactory()->count($count);
    }

    /**
     * Configure the factory.
     *
     * @return $this
     */
    public function configure()
    {
        return $this;
    }

    /**
     * Get the raw attributes generated by the factory.
     *
     * @param  array<string,mixed>  $attributes
     * @param  Model|null  $parent
     * @return array<string,mixed>|list<array<string,mixed>>
     */
    public function raw($attributes = [], $parent = null)
    {
        if ($this->count === null) {
            return $this->state($attributes)->getExpandedAttributes($parent);
        }

        return array_map(function () use ($attributes, $parent) {
            return $this->state($attributes)->getExpandedAttributes($parent);
        }, range(1, $this->count));
    }

    /**
     * Create a single model and persist it to the database.
     *
     * @param  array<string,mixed>  $attributes
     * @return Model
     */
    public function createOne($attributes = [])
    {
        // @phpstan-ignore return.type
        return $this->count(null)->create($attributes);
    }

    /**
     * Create a single model and persist it to the database.
     *
     * @param  array<string,mixed>  $attributes
     * @return Model
     */
    public function createOneQuietly($attributes = [])
    {
        // @phpstan-ignore return.type
        return $this->count(null)->createQuietly($attributes);
    }

    /**
     * Create a collection of models and persist them to the database.
     *
     * @param  iterable<array<string,mixed>>  $records
     * @return EloquentCollection
     */
    public function createMany($records)
    {
        return new EloquentCollection(
            collect($records)->map(function ($record) {
                return $this->state($record)->create();
            })
        );
    }

    /**
     * Create a collection of models and persist them to the database.
     *
     * @param  iterable<array<string,mixed>>  $records
     * @return EloquentCollection
     */
    public function createManyQuietly($records)
    {
        return $this->withoutEvents(function () use ($records) {
            return $this->createMany($records);
        });
    }

    /**
     * Create a collection of models and persist them to the database.
     *
     * @param  array<string,mixed>  $attributes
     * @param  Model|null  $parent
     * @return EloquentCollection|Model
     */
    public function create($attributes = [], $parent = null)
    {
        if (! empty($attributes)) {
            return $this->state($attributes)->create([], $parent);
        }

        $results = $this->make($attributes, $parent);

        if ($results instanceof Model) {
            $this->store(collect([$results]));

            $this->callAfterCreating(collect([$results]), $parent);
        } else {
            $this->store($results);

            $this->callAfterCreating($results, $parent);
        }

        return $results;
    }

    /**
     * Create a collection of models and persist them to the database.
     *
     * @param  array<string,mixed>  $attributes
     * @param  Model|null  $parent
     * @return EloquentCollection|Model
     */
    public function createQuietly($attributes = [], $parent = null)
    {
        return $this->withoutEvents(function () use ($attributes, $parent) {
            return $this->create($attributes, $parent);
        });
    }

    /**
     * @template T
     * @param callable():T $callback
     * @return T
     */
    private function withoutEvents($callback)
    {
        if (method_exists(Model::class, 'withoutEvents')) {
            return Model::withoutEvents($callback);
        }

        $dispatcher = Model::getEventDispatcher();
        /** @var ?Dispatcher $dispatcher */

        Model::unsetEventDispatcher();

        try {
            return $callback();
        } finally {
            if ($dispatcher) {
                Model::setEventDispatcher($dispatcher);
            }
        }
    }

    /**
     * Create a callback that persists a model in the database when invoked.
     *
     * @param  array<string,mixed>  $attributes
     * @param  Model|null  $parent
     * @return Closure
     */
    public function lazy($attributes = [], $parent = null)
    {
        return function () use ($attributes, $parent) {
            return $this->create($attributes, $parent);
        };
    }

    /**
     * Set the connection name on the results and store them.
     *
     * @param  Collection  $results
     * @return void
     */
    protected function store($results)
    {
        $results->each(function ($model) {
            if (! isset($this->connection)) {
                $model->setConnection($model->newQuery()->getQuery()->getConnection()->getName());
            }

            $model->save();

            $this->createChildren($model);
        });
    }

    /**
     * Create the children for the given model.
     *
     * @param  Model  $model
     * @return void
     */
    protected function createChildren($model)
    {
        Model::unguarded(function () use ($model) {
            $this->has->each(function ($has) use ($model) {
                $has->createFor($model);
            });
        });
    }

    /**
     * Make a single instance of the model.
     *
     * @param  array<string,mixed>  $attributes
     * @return Model
     */
    public function makeOne($attributes = [])
    {
        // @phpstan-ignore return.type
        return $this->count(null)->make($attributes);
    }

    /**
     * Create a collection of models.
     *
     * @param  array<string,mixed>  $attributes
     * @param  Model|null  $parent
     * @return EloquentCollection|Model
     */
    public function make($attributes = [], $parent = null)
    {
        if (! empty($attributes)) {
            return $this->state($attributes)->make([], $parent);
        }

        if ($this->count === null) {
            $instance = $this->makeInstance($parent);
            $this->callAfterMaking(collect([$instance]));

            return $instance;
        }

        if ($this->count < 1) {
            return $this->newModel()->newCollection();
        }

        $instances = $this->newModel()->newCollection(array_map(function () use ($parent) {
            return $this->makeInstance($parent);
        }, range(1, $this->count)));

        $this->callAfterMaking($instances);

        return $instances;
    }

    /**
     * Make an instance of the model with the given attributes.
     *
     * @param  Model|null  $parent
     * @return Model
     */
    protected function makeInstance($parent)
    {
        return Model::unguarded(function () use ($parent) {
            $instance = $this->newModel($this->getExpandedAttributes($parent));

            if (isset($this->connection)) {
                $instance->setConnection($this->connection);
            }

            return $instance;
        });
    }

    /**
     * Get a raw attributes array for the model.
     *
     * @param  Model|null  $parent
     * @return mixed
     */
    protected function getExpandedAttributes($parent)
    {
        return $this->expandAttributes($this->getRawAttributes($parent));
    }

    /**
     * Get the raw attributes for the model as an array.
     *
     * @param  Model|null  $parent
     * @return array<string,mixed>
     */
    protected function getRawAttributes($parent)
    {
        $states = $this->for->isEmpty()
            ? $this->states
            : new Collection(array_merge([function () {
                return $this->parentResolvers();
            }], $this->states->all()));

        return $states->reduce(function ($carry, $state) use ($parent) {
            if ($state instanceof Closure) {
                $state = $state->bindTo($this);
            }

            return array_merge($carry, $state($carry, $parent));
        }, $this->definition());
    }

    /**
     * Create the parent relationship resolvers (as deferred Closures).
     *
     * @return array<string,mixed>
     */
    protected function parentResolvers()
    {
        $model = $this->newModel();

        return $this->for->map(function (BelongsToRelationship $for) use ($model) {
            return $for->attributesFor($model);
        })->collapse()->all();
    }

    /**
     * Expand all attributes to their underlying values.
     *
     * @param  array<string,mixed>  $definition
     * @return array<string,mixed>
     */
    protected function expandAttributes($definition)
    {
        return collect($definition)->map(function ($attribute, $key) use (&$definition) {
            if (is_callable($attribute) && ! is_string($attribute) && ! is_array($attribute)) {
                $attribute = $attribute($definition);
            }

            if ($attribute instanceof self) {
                // @phpstan-ignore method.notFound
                $attribute = $attribute->create()->getKey();
            } elseif ($attribute instanceof Model) {
                $attribute = $attribute->getKey();
            }

            $definition[$key] = $attribute;

            return $attribute;
        })->all();
    }

    /**
     * Add a new state transformation to the model definition.
     *
     * @param  callable|array<string,mixed>  $state
     * @return static
     */
    public function state($state)
    {
        return $this->newInstance([
            'states' => $this->concat($this->states, [
                is_callable($state) ? $state : function () use ($state) {
                    return $state;
                },
            ]),
        ]);
    }

    /**
     * Add a new sequenced state transformation to the model definition.
     *
     * @param  list<array<string,mixed>>  $sequence
     * @return static
     */
    public function sequence()
    {
        return $this->state((new ReflectionClass(Sequence::class))->newInstanceArgs(func_get_args()));
    }

    /**
     * Add a new cross joined sequenced state transformation to the model definition.
     *
     * @param  list<array<string,mixed>>  $sequence
     * @return static
     */
    public function crossJoinSequence()
    {
        return $this->state((new ReflectionClass(CrossJoinSequence::class))->newInstanceArgs(func_get_args()));
    }

    /**
     * Define a child relationship for the model.
     *
     * @param  Factory  $factory
     * @param  string|null  $relationship
     * @return static
     */
    public function has($factory, $relationship = null)
    {
        return $this->newInstance([
            'has' => $this->concat($this->has, [new Relationship(
                $factory,
                $relationship ?: $this->guessRelationship($factory->modelName())
            )]),
        ]);
    }

    /**
     * Attempt to guess the relationship name for a "has" relationship.
     *
     * @param  string  $related
     * @return string
     */
    protected function guessRelationship($related)
    {
        $guess = Str::camel(Str::plural(class_basename($related)));

        return method_exists($this->modelName(), $guess) ? $guess : Str::singular($guess);
    }

    /**
     * Define an attached relationship for the model.
     *
     * @param  \Illuminate\Database\Eloquent\Factories\Factory|\Illuminate\Support\Collection|Model  $factory
     * @param  callable|array<string,mixed>  $pivot
     * @param  string|null  $relationship
     * @return static
     */
    public function hasAttached($factory, $pivot = [], $relationship = null)
    {
        return $this->newInstance([
            'has' => $this->concat($this->has, [new BelongsToManyRelationship(
                $factory,
                $pivot,
                $relationship ?: Str::camel(Str::plural(class_basename(
                    $factory instanceof Factory
                        ? $factory->modelName()
                        : $this->wrap($factory)->first()
                )))
            )]),
        ]);
    }

    /**
     * Define a parent relationship for the model.
     *
     * @param  Factory|Model  $factory
     * @param  string|null  $relationship
     * @return static
     */
    public function forModel($factory, $relationship = null)
    {
        return $this->newInstance(['for' => $this->concat($this->for, [new BelongsToRelationship(
            $factory,
            $relationship ?: Str::camel(class_basename(
                $factory instanceof Factory ? $factory->modelName() : $factory
            ))
        )])]);
    }

    /**
     * Add a new "after making" callback to the model definition.
     *
     * @param  Closure  $callback
     * @return static
     */
    public function afterMaking($callback)
    {
        return $this->newInstance(['afterMaking' => $this->concat($this->afterMaking, [$callback])]);
    }

    /**
     * Add a new "after creating" callback to the model definition.
     *
     * @param  Closure  $callback
     * @return static
     */
    public function afterCreating($callback)
    {
        return $this->newInstance(['afterCreating' => $this->concat($this->afterCreating, [$callback])]);
    }

    /**
     * Call the "after making" callbacks for the given model instances.
     *
     * @param  Collection  $instances
     * @return void
     */
    protected function callAfterMaking($instances)
    {
        $instances->each(function ($model) {
            $this->afterMaking->each(function ($callback) use ($model) {
                $callback($model);
            });
        });
    }

    /**
     * Call the "after creating" callbacks for the given model instances.
     *
     * @param  Collection  $instances
     * @param  Model|null  $parent
     * @return void
     */
    protected function callAfterCreating($instances, $parent = null)
    {
        $instances->each(function ($model) use ($parent) {
            $this->afterCreating->each(function ($callback) use ($model, $parent) {
                $callback($model, $parent);
            });
        });
    }

    /**
     * Specify how many models should be generated.
     *
     * @param  int|null  $count
     * @return static
     */
    public function count($count)
    {
        return $this->newInstance(['count' => $count]);
    }

    /**
     * Specify the database connection that should be used to generate models.
     *
     * @param  string  $connection
     * @return static
     */
    public function connection($connection)
    {
        return $this->newInstance(['connection' => $connection]);
    }

    /**
     * Create a new instance of the factory builder with the given mutated properties.
     *
     * @param  array<string,mixed>  $arguments
     * @return static
     */
    protected function newInstance($arguments = [])
    {
        $params = array_merge([
            'count' => $this->count,
            'states' => $this->states,
            'has' => $this->has,
            'for' => $this->for,
            'afterMaking' => $this->afterMaking,
            'afterCreating' => $this->afterCreating,
            'connection' => $this->connection,
        ], $arguments);

        return new static(
            $params['count'],
            $params['states'],
            $params['has'],
            $params['for'],
            $params['afterMaking'],
            $params['afterCreating'],
            $params['connection']
        );
    }

    /**
     * Get a new model instance.
     *
     * @param  array<string,mixed>  $attributes
     * @return Model
     */
    public function newModel($attributes = [])
    {
        $model = $this->modelName();

        return new $model($attributes);
    }

    /**
     * Get the name of the model that is generated by the factory.
     *
     * @return class-string<Model>
     */
    public function modelName()
    {
        $resolver = static::$modelNameResolver ?: function (self $factory) {
            $namespacedFactoryBasename = static::replaceLast(
                'Factory',
                '',
                static::replaceFirst(static::$namespace, '', get_class($factory))
            );

            $factoryBasename = static::replaceLast('Factory', '', class_basename($factory));

            $appNamespace = static::appNamespace();

            return class_exists($appNamespace.'Models\\'.$namespacedFactoryBasename)
                        ? $appNamespace.'Models\\'.$namespacedFactoryBasename
                        : $appNamespace.$factoryBasename;
        };

        return $this->model ?: $resolver($this);
    }

    /**
     * Specify the callback that should be invoked to guess model names based on factory names.
     *
     * @param  callable  $callback
     * @return void
     */
    public static function guessModelNamesUsing(callable $callback)
    {
        static::$modelNameResolver = $callback;
    }

    /**
     * Specify the default namespace that contains the application's model factories.
     *
     * @param  string  $namespace
     * @return void
     */
    public static function useNamespace($namespace)
    {
        static::$namespace = $namespace;
    }

    /**
     * Get a new factory instance for the given model name.
     *
     * @param  string  $modelName
     * @return static
     */
    public static function factoryForModel($modelName)
    {
        $factory = static::resolveFactoryName($modelName);

        return $factory::newFactory();
    }

    /**
     * Specify the callback that should be invoked to guess factory names based on dynamic relationship names.
     *
     * @param  callable  $callback
     * @return void
     */
    public static function guessFactoryNamesUsing($callback)
    {
        static::$factoryNameResolver = $callback;
    }

    /**
     * Get a new Faker instance.
     *
     * @return \Faker\Generator
     */
    protected function withFaker()
    {
        return Container::getInstance()->make(Generator::class);
    }

    /**
     * Get the factory name for the given model name.
     *
     * @param  string  $modelName
     * @return string
     */
    public static function resolveFactoryName($modelName)
    {
        $resolver = static::$factoryNameResolver ?: function ($modelName) {
            $appNamespace = static::appNamespace();

            $modelName = Str::startsWith($modelName, $appNamespace.'Models\\')
                ? self::after($modelName, $appNamespace.'Models\\')
                : self::after($modelName, $appNamespace);

            return static::$namespace.$modelName.'Factory';
        };

        return $resolver($modelName);
    }

    /**
     * Get the application namespace for the application.
     *
     * @return string
     */
    protected static function appNamespace()
    {
        try {
            return Container::getInstance()
                            ->make(Application::class)
                            ->getNamespace();
        } catch (Throwable $e) {
            return 'App\\';
        }
    }

    /**
     * Proxy dynamic factory methods onto their proper methods.
     *
     * @param  string  $method
     * @param  list<mixed>  $parameters
     * @return mixed
     */
    public function __call($method, $parameters)
    {
        if ($method === 'for') {
            return $this->forModel($parameters[0], isset($parameters[1]) ? $parameters[1] : null);
        }

        if (static::hasMacro($method)) {
            return $this->macroCall($method, $parameters);
        }

        if (! Str::startsWith($method, ['for', 'has'])) {
            static::throwBadMethodCallException($method);
        }

        $relationship = Str::camel(Str::substr($method, 3));

        $relatedModel = get_class($this->newModel()->{$relationship}()->getRelated());
        assert(is_string($relatedModel));

        if (method_exists($relatedModel, 'newFactory')) {
            $factory = $relatedModel::newFactory() ?: static::factoryForModel($relatedModel);
        } else {
            $factory = static::factoryForModel($relatedModel);
        }

        if (Str::startsWith($method, 'for')) {
            return $this->for($factory->state(isset($parameters[0]) ? $parameters[0] : []), $relationship);
        } elseif (Str::startsWith($method, 'has')) {
            $count = isset($parameters[0]) && is_numeric($parameters[0])
                ? $parameters[0]
                : 1;
            
            $state = isset($parameters[0]) && is_array($parameters[0])
                ? $parameters[0]
                : (isset($parameters[1]) ? $parameters[1] : []);

            return $this->has(
                $factory
                    ->count($count)
                    ->state($state),
                $relationship
            );
        }
    }

    /**
     * Proxy static factory methods onto their proper methods.
     *
     * @param  string  $method
     * @param  list<mixed>  $parameters
     * @return mixed
     */
    public static function __callStatic($method, $parameters)
    {
        if ($method === 'new') {
            return static::newFactory(isset($parameters[0]) ? $parameters[0] : []);
        }

        $this->throwBadMethodCallException($method);
    }

    /**
     * Throw a bad method call exception for the given method.
     *
     * @param  string  $method
     * @return void
     *
     * @throws \BadMethodCallException
     */
    protected static function throwBadMethodCallException($method)
    {
        throw new BadMethodCallException(sprintf(
            'Call to undefined method %s::%s()',
            static::class,
            $method
        ));
    }

    /**
     * @template T
     * @param Collection<int,T> $collection
     * @param iterable<T> $source
     * @return Collection<int,T>
     */
    private function concat(Collection $collection, $source)
    {
        $result = new Collection($collection);

        foreach ($source as $item) {
            $result->push($item);
        }

        return $result;
    }


    /**
     * @param mixed $value
     * @return Collection
     */
    private function wrap($value)
    {
        if ($value instanceof Collection) {
            return new Collection($value);
        } elseif (is_array($value)) {
            return new Collection($value);
        } else {
            return new Collection([$value]);
        }
    }

    /**
     * @param string $subject
     * @param string $search
     * @return string
     */
    private static function after($subject, $search)
    {
        return $search === '' ? $subject : array_reverse(explode($search, $subject, 2))[0];
    }

    /**
     * Replace the first occurrence of a given value in the string.
     *
     * @param  string  $search
     * @param  string  $replace
     * @param  string  $subject
     * @return string
     */
    private static function replaceFirst($search, $replace, $subject)
    {
        $position = strpos($subject, $search);

        if ($position !== false) {
            return substr_replace($subject, $replace, $position, strlen($search));
        }

        return $subject;
    }

    /**
     * Replace the last occurrence of a given value in the string.
     *
     * @param  string  $search
     * @param  string  $replace
     * @param  string  $subject
     * @return string
     */
    private static function replaceLast($search, $replace, $subject)
    {
        $position = strrpos($subject, $search);

        if ($position !== false) {
            return substr_replace($subject, $replace, $position, strlen($search));
        }

        return $subject;
    }
}
